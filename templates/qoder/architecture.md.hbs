---
trigger: manual
---
# Architecture Patterns for {{project.name}}

> Design patterns and architectural guidelines

## ğŸ—ï¸ Architectural Principles

**Core Principles:**
1. **Separation of Concerns** - Each module has a single responsibility
2. **Dependency Injection** - Loose coupling between components
3. **SOLID Principles** - Maintainable and scalable code
4. **DRY (Don't Repeat Yourself)** - Reusable code
5. **YAGNI (You Aren't Gonna Need It)** - Don't over-engineer

---

{{#if (contains detection.frameworks.[0].name "Next.js")}}
## Next.js Architecture

### App Router Structure

```
app/
â”œâ”€â”€ (auth)/              # Route group for auth pages
â”‚   â”œâ”€â”€ login/
â”‚   â””â”€â”€ register/
â”œâ”€â”€ (dashboard)/         # Protected dashboard routes
â”‚   â”œâ”€â”€ layout.tsx      # Dashboard layout
â”‚   â”œâ”€â”€ page.tsx        # Dashboard home
â”‚   â””â”€â”€ settings/
â”œâ”€â”€ api/                 # API routes
â”‚   â”œâ”€â”€ auth/
â”‚   â””â”€â”€ users/
â”œâ”€â”€ layout.tsx          # Root layout
â””â”€â”€ page.tsx            # Home page

components/
â”œâ”€â”€ ui/                 # Reusable UI components
â”‚   â”œâ”€â”€ button.tsx
â”‚   â”œâ”€â”€ card.tsx
â”‚   â””â”€â”€ input.tsx
â”œâ”€â”€ forms/              # Form components
â””â”€â”€ layouts/            # Layout components

lib/
â”œâ”€â”€ db/                 # Database utilities
â”œâ”€â”€ auth/               # Auth helpers
â”œâ”€â”€ api/                # API clients
â””â”€â”€ utils/              # General utilities
```

### Server vs Client Components

**Server Components (Default):**
- Data fetching
- Direct database access
- Server-side logic
- SEO content

**Client Components ('use client'):**
- Interactive elements
- Event handlers
- Browser APIs (useState, useEffect)
- Third-party libraries using React hooks

```typescript
// Server Component (default)
async function UserList() {
  const users = await prisma.user.findMany();

  return (
    <div>
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}

// Client Component
'use client';

function UserCard({ user }: { user: User }) {
  const [isExpanded, setIsExpanded] = useState(false);

  return (
    <div onClick={() => setIsExpanded(!isExpanded)}>
      {/* Interactive content */}
    </div>
  );
}
```

### Data Fetching Patterns

```typescript
// Server Component with caching
async function getUsers() {
  const users = await prisma.user.findMany();
  return users;
}

// With revalidation
export const revalidate = 3600; // Revalidate every hour

// Dynamic route with params
async function UserPage({ params }: { params: { id: string } }) {
  const user = await prisma.user.findUnique({
    where: { id: params.id }
  });

  if (!user) {
    notFound();
  }

  return <div>{user.name}</div>;
}

// Server Actions for mutations
async function createUser(formData: FormData) {
  'use server';

  const name = formData.get('name') as string;
  const email = formData.get('email') as string;

  await prisma.user.create({
    data: { name, email }
  });

  revalidatePath('/users');
  redirect('/users');
}
```

{{else if (contains detection.frameworks.[0].name "React")}}
## React Architecture

### Component Hierarchy

```
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ common/         # Reusable components
â”‚   â”‚   â”œâ”€â”€ Button/
â”‚   â”‚   â”œâ”€â”€ Input/
â”‚   â”‚   â””â”€â”€ Modal/
â”‚   â”œâ”€â”€ features/       # Feature-specific components
â”‚   â”‚   â”œâ”€â”€ Auth/
â”‚   â”‚   â”œâ”€â”€ Dashboard/
â”‚   â”‚   â””â”€â”€ Profile/
â”‚   â””â”€â”€ layouts/        # Layout components
â”‚       â”œâ”€â”€ AppLayout/
â”‚       â””â”€â”€ AuthLayout/
â”œâ”€â”€ hooks/              # Custom hooks
â”‚   â”œâ”€â”€ useAuth.ts
â”‚   â”œâ”€â”€ useApi.ts
â”‚   â””â”€â”€ useLocalStorage.ts
â”œâ”€â”€ contexts/           # React contexts
â”‚   â”œâ”€â”€ AuthContext.tsx
â”‚   â””â”€â”€ ThemeContext.tsx
â”œâ”€â”€ services/           # API services
â”‚   â”œâ”€â”€ api.ts
â”‚   â””â”€â”€ auth.ts
â”œâ”€â”€ utils/              # Utilities
â””â”€â”€ types/              # TypeScript types
```

### Component Patterns

**Container/Presentation Pattern:**

```typescript
// Container Component (logic)
function UserListContainer() {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUsers().then(data => {
      setUsers(data);
      setLoading(false);
    });
  }, []);

  if (loading) return <Spinner />;

  return <UserList users={users} />;
}

// Presentation Component (UI only)
interface UserListProps {
  users: User[];
}

function UserList({ users }: UserListProps) {
  return (
    <div>
      {users.map(user => (
        <UserItem key={user.id} user={user} />
      ))}
    </div>
  );
}
```

**Custom Hooks for Logic Reuse:**

```typescript
// hooks/useUsers.ts
function useUsers() {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    fetchUsers()
      .then(setUsers)
      .catch(setError)
      .finally(() => setLoading(false));
  }, []);

  const refetch = useCallback(() => {
    setLoading(true);
    fetchUsers()
      .then(setUsers)
      .catch(setError)
      .finally(() => setLoading(false));
  }, []);

  return { users, loading, error, refetch };
}

// Usage
function UserList() {
  const { users, loading, error, refetch } = useUsers();

  if (loading) return <Spinner />;
  if (error) return <Error error={error} />;

  return <div>{/* Render users */}</div>;
}
```

### State Management

{{#if (includes detection.dependencies "zustand")}}
**Zustand:**

```typescript
import create from 'zustand';

interface UserStore {
  users: User[];
  loading: boolean;
  fetchUsers: () => Promise<void>;
  addUser: (user: User) => void;
}

export const useUserStore = create<UserStore>((set) => ({
  users: [],
  loading: false,
  fetchUsers: async () => {
    set({ loading: true });
    const users = await api.getUsers();
    set({ users, loading: false });
  },
  addUser: (user) => set((state) => ({
    users: [...state.users, user]
  }))
}));
```

{{else if (includes detection.dependencies "redux")}}
**Redux Toolkit:**

```typescript
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

export const fetchUsers = createAsyncThunk(
  'users/fetch',
  async () => {
    return await api.getUsers();
  }
);

const userSlice = createSlice({
  name: 'users',
  initialState: {
    users: [],
    loading: false,
    error: null
  },
  reducers: {
    addUser: (state, action) => {
      state.users.push(action.payload);
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.users = action.payload;
        state.loading = false;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.error = action.error.message;
        state.loading = false;
      });
  }
});
```

{{else}}
**Context + Reducer:**

```typescript
// Context
const UserContext = createContext<UserContextType | undefined>(undefined);

// Reducer
function userReducer(state: UserState, action: UserAction): UserState {
  switch (action.type) {
    case 'SET_USERS':
      return { ...state, users: action.payload };
    case 'ADD_USER':
      return { ...state, users: [...state.users, action.payload] };
    case 'SET_LOADING':
      return { ...state, loading: action.payload };
    default:
      return state;
  }
}

// Provider
export function UserProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(userReducer, initialState);

  const fetchUsers = useCallback(async () => {
    dispatch({ type: 'SET_LOADING', payload: true });
    const users = await api.getUsers();
    dispatch({ type: 'SET_USERS', payload: users });
    dispatch({ type: 'SET_LOADING', payload: false });
  }, []);

  return (
    <UserContext.Provider value=\{\{ ...state, fetchUsers \}\}>
      \{children\}
    </UserContext.Provider>
  );
}
```
{{/if}}

{{else if (contains detection.frameworks.[0].name "Express")}}
## Express.js Architecture

### Layered Architecture

```
src/
â”œâ”€â”€ routes/             # API routes
â”‚   â”œâ”€â”€ auth.routes.ts
â”‚   â””â”€â”€ user.routes.ts
â”œâ”€â”€ controllers/        # Request handlers
â”‚   â”œâ”€â”€ auth.controller.ts
â”‚   â””â”€â”€ user.controller.ts
â”œâ”€â”€ services/           # Business logic
â”‚   â”œâ”€â”€ auth.service.ts
â”‚   â””â”€â”€ user.service.ts
â”œâ”€â”€ repositories/       # Data access
â”‚   â”œâ”€â”€ user.repository.ts
â”‚   â””â”€â”€ session.repository.ts
â”œâ”€â”€ models/             # Data models
â”‚   â”œâ”€â”€ User.ts
â”‚   â””â”€â”€ Session.ts
â”œâ”€â”€ middleware/         # Express middleware
â”‚   â”œâ”€â”€ auth.ts
â”‚   â”œâ”€â”€ validation.ts
â”‚   â””â”€â”€ error.ts
â”œâ”€â”€ utils/              # Utilities
â””â”€â”€ index.ts
```

### Clean Architecture Pattern

```typescript
// Repository Layer (Data Access)
class UserRepository {
  async findById(id: string): Promise<User | null> {
    return await db.user.findUnique({ where: { id } });
  }

  async create(data: CreateUserDTO): Promise<User> {
    return await db.user.create({ data });
  }

  async update(id: string, data: UpdateUserDTO): Promise<User> {
    return await db.user.update({ where: { id }, data });
  }
}

// Service Layer (Business Logic)
class UserService {
  constructor(private userRepo: UserRepository) {}

  async getUser(id: string): Promise<User> {
    const user = await this.userRepo.findById(id);

    if (!user) {
      throw new NotFoundError('User', id);
    }

    return user;
  }

  async createUser(data: CreateUserDTO): Promise<User> {
    // Validate
    validateEmail(data.email);

    // Check duplicates
    const existing = await this.userRepo.findByEmail(data.email);
    if (existing) {
      throw new ConflictError('Email already exists');
    }

    // Hash password
    const hashedPassword = await hash(data.password);

    // Create user
    return await this.userRepo.create({
      ...data,
      password: hashedPassword
    });
  }
}

// Controller Layer (HTTP Handling)
class UserController {
  constructor(private userService: UserService) {}

  getUser = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = await this.userService.getUser(req.params.id);
      res.json({ data: user });
    } catch (error) {
      next(error);
    }
  };

  createUser = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = await this.userService.createUser(req.body);
      res.status(201).json({ data: user });
    } catch (error) {
      next(error);
    }
  };
}

// Routes
const userRepo = new UserRepository();
const userService = new UserService(userRepo);
const userController = new UserController(userService);

router.get('/users/:id', userController.getUser);
router.post('/users', validate(CreateUserSchema), userController.createUser);
```

{{else if (contains detection.frameworks.[0].name "FastAPI")}}
## FastAPI Architecture

### Layered Structure

```
app/
â”œâ”€â”€ routers/            # API routers
â”‚   â”œâ”€â”€ auth.py
â”‚   â””â”€â”€ users.py
â”œâ”€â”€ services/           # Business logic
â”‚   â”œâ”€â”€ auth_service.py
â”‚   â””â”€â”€ user_service.py
â”œâ”€â”€ repositories/       # Data access
â”‚   â”œâ”€â”€ user_repository.py
â”‚   â””â”€â”€ session_repository.py
â”œâ”€â”€ models/             # SQLAlchemy models
â”‚   â”œâ”€â”€ user.py
â”‚   â””â”€â”€ session.py
â”œâ”€â”€ schemas/            # Pydantic schemas
â”‚   â”œâ”€â”€ user.py
â”‚   â””â”€â”€ auth.py
â”œâ”€â”€ dependencies/       # Dependency injection
â”‚   â”œâ”€â”€ auth.py
â”‚   â””â”€â”€ database.py
â”œâ”€â”€ core/               # Core configuration
â”‚   â”œâ”€â”€ config.py
â”‚   â””â”€â”€ security.py
â””â”€â”€ main.py
```

### Dependency Injection Pattern

```python
# dependencies/database.py
async def get_db() -> AsyncGenerator[AsyncSession, None]:
    async with AsyncSessionLocal() as session:
        yield session

# services/user_service.py
class UserService:
    def __init__(self, db: AsyncSession):
        self.db = db

    async def get_user(self, user_id: str) -> User:
        result = await self.db.execute(
            select(User).where(User.id == user_id)
        )
        user = result.scalar_one_or_none()

        if not user:
            raise HTTPException(
                status_code=404,
                detail={"message": "User not found", "code": "USER_NOT_FOUND"}
            )

        return user

    async def create_user(self, user_data: UserCreate) -> User:
        # Hash password
        hashed_password = get_password_hash(user_data.password)

        # Create user
        user = User(
            email=user_data.email,
            name=user_data.name,
            hashed_password=hashed_password
        )

        self.db.add(user)
        await self.db.commit()
        await self.db.refresh(user)

        return user

# dependencies/users.py
async def get_user_service(
    db: AsyncSession = Depends(get_db)
) -> UserService:
    return UserService(db)

# routers/users.py
@router.get("/users/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: str,
    user_service: UserService = Depends(get_user_service),
    current_user: User = Depends(get_current_user)
):
    return await user_service.get_user(user_id)

@router.post("/users", response_model=UserResponse, status_code=201)
async def create_user(
    user_data: UserCreate,
    user_service: UserService = Depends(get_user_service)
):
    return await user_service.create_user(user_data)
```

{{/if}}

---

## Design Patterns

### Repository Pattern

**Benefits:**
- Abstracts data access
- Testable with mock repositories
- Swappable data sources

### Service Layer Pattern

**Benefits:**
- Business logic separation
- Reusable across controllers
- Easier to test

### Dependency Injection

**Benefits:**
- Loose coupling
- Testability
- Flexibility

---

## SOLID Principles

**S - Single Responsibility:**
- Each class/function has one job
- Easier to understand and maintain

**O - Open/Closed:**
- Open for extension
- Closed for modification

**L - Liskov Substitution:**
- Subtypes must be substitutable for base types

**I - Interface Segregation:**
- Many specific interfaces > one general interface

**D - Dependency Inversion:**
- Depend on abstractions, not concretions

---

## Related Rules

- **Core**: `@core.md` - General coding principles
- **Requirements**: `@requirements-spec.md` - Architecture requirements
- **Testing**: `@testing.md` - Testing architecture
{{#if (includes project.type "api")}}
- **API Design**: `@api-design.md` - API architecture
{{/if}}

---

*Generated by Brief v{{generated.version}} for Qoder IDE*
*Good architecture = maintainable code*
