---
description: TypeScript coding standards and type safety guidelines
globs:
  - "**/*.ts"
  - "**/*.tsx"
priority: 900
---

# TypeScript Standards

## Type Safety

### Strict Mode Requirements

- Enable all strict TypeScript flags
- Never use `any` - use `unknown` for truly unknown types
- Avoid type assertions (`as`) - prefer type guards
- Use explicit return types for public functions

### Type Definitions

```typescript
// Prefer interfaces for object shapes
interface User {
  id: string;
  name: string;
  email: string;
}

// Use type for unions, intersections, and complex types
type Status = "pending" | "active" | "inactive";
type UserWithRole = User & { role: Role };
```

### Generics

- Use meaningful generic names: `TData`, `TError`, `TResult`
- Constrain generics when possible: `<T extends object>`
- Provide defaults when appropriate: `<T = unknown>`

## Best Practices

### Null Handling

```typescript
// Use nullish coalescing
const value = input ?? defaultValue;

// Use optional chaining
const name = user?.profile?.name;

// Prefer undefined over null for optional values
interface Options {
  timeout?: number; // undefined when not provided
}
```

### Const Assertions

```typescript
// Use const assertions for literal types
const ROUTES = {
  home: "/",
  about: "/about",
} as const;

type Route = (typeof ROUTES)[keyof typeof ROUTES];
```

### Enums vs Union Types

```typescript
// Prefer union types for simple cases
type Direction = "north" | "south" | "east" | "west";

// Use const objects for values that need iteration
const Status = {
  Pending: "pending",
  Active: "active",
} as const;
```

## Function Patterns

### Parameter Objects

```typescript
// Use object parameters for 3+ arguments
function createUser(options: {
  name: string;
  email: string;
  role?: string;
}): User {
  // ...
}
```

### Return Types

```typescript
// Always specify return types for public functions
function calculateTotal(items: Item[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// Use Result types for operations that can fail
type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };
```

## Import Organization

1. External libraries
2. Internal modules (absolute paths)
3. Relative imports
4. Type-only imports last

```typescript
import { useState } from "react";
import { api } from "@/lib/api";
import { Button } from "../components/Button";
import type { User } from "./types";
```

## Avoid These Patterns

- `any` type - use `unknown` instead
- Non-null assertions (`!`) - use proper null checks
- `@ts-ignore` - fix the type issue instead
- Implicit `any` in callbacks - always type parameters
