---
description: React component patterns and hooks best practices
globs:
  - "**/*.tsx"
  - "**/*.jsx"
  - "**/components/**/*"
  - "**/hooks/**/*"
priority: 800
---

# React Development Standards

## Component Patterns

### Functional Components

```tsx
interface ButtonProps {
  children: React.ReactNode;
  variant?: "primary" | "secondary";
  onClick?: () => void;
  disabled?: boolean;
}

export function Button({
  children,
  variant = "primary",
  onClick,
  disabled = false,
}: ButtonProps): React.ReactElement {
  return (
    <button
      className={`btn btn-${variant}`}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
}
```

### Component Organization

```
components/
├── Button/
│   ├── Button.tsx        # Main component
│   ├── Button.test.tsx   # Tests
│   ├── Button.module.css # Styles (if applicable)
│   └── index.ts          # Export
└── index.ts              # Barrel export
```

## Hooks Best Practices

### useState

```tsx
// Use functional updates for state based on previous value
setCount((prev) => prev + 1);

// Group related state
const [form, setForm] = useState({ name: "", email: "" });

// Or use useReducer for complex state
```

### useEffect

```tsx
// Always include dependencies
useEffect(() => {
  const subscription = api.subscribe(id);
  return () => subscription.unsubscribe();
}, [id]); // Include all used values

// Separate concerns into multiple effects
useEffect(() => { /* fetch data */ }, [id]);
useEffect(() => { /* update title */ }, [title]);
```

### Custom Hooks

```tsx
// Extract reusable logic
function useLocalStorage<T>(key: string, initialValue: T) {
  const [value, setValue] = useState<T>(() => {
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : initialValue;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue] as const;
}
```

## Performance Optimization

### Memoization

```tsx
// Memoize expensive computations
const sortedItems = useMemo(
  () => items.sort((a, b) => a.name.localeCompare(b.name)),
  [items]
);

// Memoize callbacks passed to children
const handleClick = useCallback(() => {
  onItemClick(item.id);
}, [item.id, onItemClick]);

// Memoize components that receive stable props
const MemoizedList = React.memo(ItemList);
```

### Lazy Loading

```tsx
// Lazy load routes/components
const Dashboard = lazy(() => import("./pages/Dashboard"));

// Use Suspense for loading states
<Suspense fallback={<LoadingSpinner />}>
  <Dashboard />
</Suspense>
```

## State Management

### Context Pattern

```tsx
interface ThemeContextValue {
  theme: "light" | "dark";
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextValue | null>(null);

export function useTheme(): ThemeContextValue {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error("useTheme must be used within ThemeProvider");
  }
  return context;
}
```

## Event Handling

```tsx
// Type event handlers properly
function handleChange(e: React.ChangeEvent<HTMLInputElement>) {
  setValue(e.target.value);
}

function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
  e.preventDefault();
  // ...
}
```

## Avoid These Patterns

- Inline function definitions in JSX (causes re-renders)
- Missing keys in lists or using index as key
- Direct DOM manipulation (use refs)
- Mutating state directly
- useEffect for derived state (use useMemo)
- Over-using context for frequently changing values
